import { g as Vt, w as Bt, c as D } from "../core-bcd69edc.js";
import { Z as Kt, b as Jt, d as Qt, p as Yt, s as rn } from "../core-bcd69edc.js";
var Gr = (() => {
  var I = import.meta.url;
  return function(Q = {}) {
    var f = Q, Y, M;
    f.ready = new Promise((r, e) => {
      Y = r, M = e;
    });
    var rr = Object.assign({}, f), er = typeof window == "object", tr = typeof importScripts == "function";
    typeof process == "object" && typeof process.versions == "object" && process.versions.node;
    var R = "";
    function Kr(r) {
      return f.locateFile ? f.locateFile(r, R) : R + r;
    }
    var lr;
    (er || tr) && (tr ? R = self.location.href : typeof document < "u" && document.currentScript && (R = document.currentScript.src), I && (R = I), R.indexOf("blob:") !== 0 ? R = R.substr(0, R.replace(/[?#].*/, "").lastIndexOf("/") + 1) : R = "", tr && (lr = (r) => {
      var e = new XMLHttpRequest();
      return e.open("GET", r, !1), e.responseType = "arraybuffer", e.send(null), new Uint8Array(e.response);
    })), f.print || console.log.bind(console);
    var N = f.printErr || console.error.bind(console);
    Object.assign(f, rr), rr = null, f.arguments && f.arguments, f.thisProgram && f.thisProgram, f.quit && f.quit;
    var X;
    f.wasmBinary && (X = f.wasmBinary), typeof WebAssembly != "object" && z("no native wasm support detected");
    var nr, yr = !1;
    function Jr(r, e) {
      r || z(e);
    }
    var U, b, L, ir, H, d, mr, br;
    function wr() {
      var r = nr.buffer;
      f.HEAP8 = U = new Int8Array(r), f.HEAP16 = L = new Int16Array(r), f.HEAPU8 = b = new Uint8Array(r), f.HEAPU16 = ir = new Uint16Array(r), f.HEAP32 = H = new Int32Array(r), f.HEAPU32 = d = new Uint32Array(r), f.HEAPF32 = mr = new Float32Array(r), f.HEAPF64 = br = new Float64Array(r);
    }
    var Ar = [], Tr = [], $r = [];
    function Qr() {
      if (f.preRun)
        for (typeof f.preRun == "function" && (f.preRun = [f.preRun]); f.preRun.length; )
          ee(f.preRun.shift());
      vr(Ar);
    }
    function Yr() {
      vr(Tr);
    }
    function re() {
      if (f.postRun)
        for (typeof f.postRun == "function" && (f.postRun = [f.postRun]); f.postRun.length; )
          ne(f.postRun.shift());
      vr($r);
    }
    function ee(r) {
      Ar.unshift(r);
    }
    function te(r) {
      Tr.unshift(r);
    }
    function ne(r) {
      $r.unshift(r);
    }
    var S = 0, q = null;
    function ie(r) {
      S++, f.monitorRunDependencies && f.monitorRunDependencies(S);
    }
    function ae(r) {
      if (S--, f.monitorRunDependencies && f.monitorRunDependencies(S), S == 0 && q) {
        var e = q;
        q = null, e();
      }
    }
    function z(r) {
      f.onAbort && f.onAbort(r), r = "Aborted(" + r + ")", N(r), yr = !0, r += ". Build with -sASSERTIONS for more info.";
      var e = new WebAssembly.RuntimeError(r);
      throw M(e), e;
    }
    var oe = "data:application/octet-stream;base64,", Er = (r) => r.startsWith(oe), x;
    f.locateFile ? (x = "zxing_writer.wasm", Er(x) || (x = Kr(x))) : x = new URL("/writer/zxing_writer.wasm", self.location).href;
    function Rr(r) {
      if (r == x && X)
        return new Uint8Array(X);
      if (lr)
        return lr(r);
      throw "both async and sync fetching of the wasm failed";
    }
    function se(r) {
      return !X && (er || tr) && typeof fetch == "function" ? fetch(r, { credentials: "same-origin" }).then((e) => {
        if (!e.ok)
          throw "failed to load wasm binary file at '" + r + "'";
        return e.arrayBuffer();
      }).catch(() => Rr(r)) : Promise.resolve().then(() => Rr(r));
    }
    function Cr(r, e, t) {
      return se(r).then((n) => WebAssembly.instantiate(n, e)).then((n) => n).then(t, (n) => {
        N(`failed to asynchronously prepare wasm: ${n}`), z(n);
      });
    }
    function fe(r, e, t, n) {
      return !r && typeof WebAssembly.instantiateStreaming == "function" && !Er(e) && typeof fetch == "function" ? fetch(e, { credentials: "same-origin" }).then((i) => {
        var a = WebAssembly.instantiateStreaming(i, t);
        return a.then(n, function(o) {
          return N(`wasm streaming compile failed: ${o}`), N("falling back to ArrayBuffer instantiation"), Cr(e, t, n);
        });
      }) : Cr(e, t, n);
    }
    function ce() {
      var r = { a: $t };
      function e(n, i) {
        return h = n.exports, nr = h.S, wr(), jr = h.W, te(h.T), ae(), h;
      }
      ie();
      function t(n) {
        e(n.instance);
      }
      if (f.instantiateWasm)
        try {
          return f.instantiateWasm(r, e);
        } catch (n) {
          N(`Module.instantiateWasm callback failed with error: ${n}`), M(n);
        }
      return fe(X, x, r, t).catch(M), {};
    }
    var vr = (r) => {
      for (; r.length > 0; )
        r.shift()(f);
    };
    f.noExitRuntime;
    var ar = [], ue = (r) => {
      var e = new dr(r);
      return e.get_caught() || e.set_caught(!0), e.set_rethrown(!1), ar.push(e), Xr(e.excPtr), e.get_exception_ptr();
    }, P = 0, le = () => {
      p(0, 0);
      var r = ar.pop();
      Nr(r.excPtr), P = 0;
    };
    function dr(r) {
      this.excPtr = r, this.ptr = r - 24, this.set_type = function(e) {
        d[this.ptr + 4 >> 2] = e;
      }, this.get_type = function() {
        return d[this.ptr + 4 >> 2];
      }, this.set_destructor = function(e) {
        d[this.ptr + 8 >> 2] = e;
      }, this.get_destructor = function() {
        return d[this.ptr + 8 >> 2];
      }, this.set_caught = function(e) {
        e = e ? 1 : 0, U[this.ptr + 12 >> 0] = e;
      }, this.get_caught = function() {
        return U[this.ptr + 12 >> 0] != 0;
      }, this.set_rethrown = function(e) {
        e = e ? 1 : 0, U[this.ptr + 13 >> 0] = e;
      }, this.get_rethrown = function() {
        return U[this.ptr + 13 >> 0] != 0;
      }, this.init = function(e, t) {
        this.set_adjusted_ptr(0), this.set_type(e), this.set_destructor(t);
      }, this.set_adjusted_ptr = function(e) {
        d[this.ptr + 16 >> 2] = e;
      }, this.get_adjusted_ptr = function() {
        return d[this.ptr + 16 >> 2];
      }, this.get_exception_ptr = function() {
        var e = qr(this.get_type());
        if (e)
          return d[this.excPtr >> 2];
        var t = this.get_adjusted_ptr();
        return t !== 0 ? t : this.excPtr;
      };
    }
    var ve = (r) => {
      throw P || (P = r), P;
    }, _r = (r) => {
      var e = P;
      if (!e)
        return K(0), 0;
      var t = new dr(e);
      t.set_adjusted_ptr(e);
      var n = t.get_type();
      if (!n)
        return K(0), e;
      for (var i in r) {
        var a = r[i];
        if (a === 0 || a === n)
          break;
        var o = t.ptr + 16;
        if (Lr(a, n, o))
          return K(a), e;
      }
      return K(n), e;
    }, de = () => _r([]), _e = (r) => _r([r]), he = (r, e) => _r([r, e]), pe = () => {
      var r = ar.pop();
      r || z("no exception to throw");
      var e = r.excPtr;
      throw r.get_rethrown() || (ar.push(r), r.set_rethrown(!0), r.set_caught(!1)), P = e, P;
    }, ge = (r, e, t) => {
      var n = new dr(r);
      throw n.init(e, t), P = r, P;
    }, or = {}, Pr = (r) => {
      for (; r.length; ) {
        var e = r.pop(), t = r.pop();
        t(e);
      }
    };
    function hr(r) {
      return this.fromWireType(H[r >> 2]);
    }
    var V = {}, O = {}, sr = {}, Fr, kr = (r) => {
      throw new Fr(r);
    }, Wr = (r, e, t) => {
      r.forEach(function(s) {
        sr[s] = e;
      });
      function n(s) {
        var c = t(s);
        c.length !== r.length && kr("Mismatched type converter count");
        for (var u = 0; u < r.length; ++u)
          F(r[u], c[u]);
      }
      var i = new Array(e.length), a = [], o = 0;
      e.forEach((s, c) => {
        O.hasOwnProperty(s) ? i[c] = O[s] : (a.push(s), V.hasOwnProperty(s) || (V[s] = []), V[s].push(() => {
          i[c] = O[s], ++o, o === a.length && n(i);
        }));
      }), a.length === 0 && n(i);
    }, ye = (r) => {
      var e = or[r];
      delete or[r];
      var t = e.rawConstructor, n = e.rawDestructor, i = e.fields, a = i.map((o) => o.getterReturnType).concat(i.map((o) => o.setterArgumentType));
      Wr([r], a, (o) => {
        var s = {};
        return i.forEach((c, u) => {
          var l = c.fieldName, v = o[u], m = c.getter, $ = c.getterContext, C = o[u + i.length], j = c.setter, E = c.setterContext;
          s[l] = { read: (J) => v.fromWireType(m($, J)), write: (J, gr) => {
            var ur = [];
            j(E, J, C.toWireType(ur, gr)), Pr(ur);
          } };
        }), [{ name: e.name, fromWireType: (c) => {
          var u = {};
          for (var l in s)
            u[l] = s[l].read(c);
          return n(c), u;
        }, toWireType: (c, u) => {
          for (var l in s)
            if (!(l in u))
              throw new TypeError(`Missing field: "${l}"`);
          var v = t();
          for (l in s)
            s[l].write(v, u[l]);
          return c !== null && c.push(n, v), v;
        }, argPackAdvance: W, readValueFromPointer: hr, destructorFunction: n }];
      });
    }, me = (r, e, t, n, i) => {
    }, be = () => {
      for (var r = new Array(256), e = 0; e < 256; ++e)
        r[e] = String.fromCharCode(e);
      Ur = r;
    }, Ur, w = (r) => {
      for (var e = "", t = r; b[t]; )
        e += Ur[b[t++]];
      return e;
    }, Sr, A = (r) => {
      throw new Sr(r);
    };
    function we(r, e, t = {}) {
      var n = e.name;
      if (r || A(`type "${n}" must have a positive integer typeid pointer`), O.hasOwnProperty(r)) {
        if (t.ignoreDuplicateRegistrations)
          return;
        A(`Cannot register type '${n}' twice`);
      }
      if (O[r] = e, delete sr[r], V.hasOwnProperty(r)) {
        var i = V[r];
        delete V[r], i.forEach((a) => a());
      }
    }
    function F(r, e, t = {}) {
      if (!("argPackAdvance" in e))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      return we(r, e, t);
    }
    var W = 8, Ae = (r, e, t, n) => {
      e = w(e), F(r, { name: e, fromWireType: function(i) {
        return !!i;
      }, toWireType: function(i, a) {
        return a ? t : n;
      }, argPackAdvance: W, readValueFromPointer: function(i) {
        return this.fromWireType(b[i]);
      }, destructorFunction: null });
    };
    function Te() {
      Object.assign(xr.prototype, { get(r) {
        return this.allocated[r];
      }, has(r) {
        return this.allocated[r] !== void 0;
      }, allocate(r) {
        var e = this.freelist.pop() || this.allocated.length;
        return this.allocated[e] = r, e;
      }, free(r) {
        this.allocated[r] = void 0, this.freelist.push(r);
      } });
    }
    function xr() {
      this.allocated = [void 0], this.freelist = [];
    }
    var T = new xr(), Or = (r) => {
      r >= T.reserved && --T.get(r).refcount === 0 && T.free(r);
    }, $e = () => {
      for (var r = 0, e = T.reserved; e < T.allocated.length; ++e)
        T.allocated[e] !== void 0 && ++r;
      return r;
    }, Ee = () => {
      T.allocated.push({ value: void 0 }, { value: null }, { value: !0 }, { value: !1 }), T.reserved = T.allocated.length, f.count_emval_handles = $e;
    }, B = { toValue: (r) => (r || A("Cannot use deleted val. handle = " + r), T.get(r).value), toHandle: (r) => {
      switch (r) {
        case void 0:
          return 1;
        case null:
          return 2;
        case !0:
          return 3;
        case !1:
          return 4;
        default:
          return T.allocate({ refcount: 1, value: r });
      }
    } }, Re = (r, e) => {
      e = w(e), F(r, { name: e, fromWireType: (t) => {
        var n = B.toValue(t);
        return Or(t), n;
      }, toWireType: (t, n) => B.toHandle(n), argPackAdvance: W, readValueFromPointer: hr, destructorFunction: null });
    }, Ce = (r, e) => {
      switch (e) {
        case 4:
          return function(t) {
            return this.fromWireType(mr[t >> 2]);
          };
        case 8:
          return function(t) {
            return this.fromWireType(br[t >> 3]);
          };
        default:
          throw new TypeError(`invalid float width (${e}): ${r}`);
      }
    }, Pe = (r, e, t) => {
      e = w(e), F(r, { name: e, fromWireType: (n) => n, toWireType: (n, i) => i, argPackAdvance: W, readValueFromPointer: Ce(e, t), destructorFunction: null });
    }, Fe = 48, ke = 57, We = (r) => {
      if (r === void 0)
        return "_unknown";
      r = r.replace(/[^a-zA-Z0-9_]/g, "$");
      var e = r.charCodeAt(0);
      return e >= Fe && e <= ke ? `_${r}` : r;
    };
    function Ue(r, e, t, n, i, a) {
      var o = e.length;
      o < 2 && A("argTypes array size mismatch! Must at least get return value and 'this' types!");
      for (var s = e[1] !== null && t !== null, c = !1, u = 1; u < e.length; ++u)
        if (e[u] !== null && e[u].destructorFunction === void 0) {
          c = !0;
          break;
        }
      var l = e[0].name !== "void", v = o - 2, m = new Array(v), $ = [], C = [];
      return function() {
        arguments.length !== v && A(`function ${r} called with ${arguments.length} arguments, expected ${v}`), C.length = 0;
        var j;
        $.length = s ? 2 : 1, $[0] = i, s && (j = e[1].toWireType(C, this), $[1] = j);
        for (var E = 0; E < v; ++E)
          m[E] = e[E + 2].toWireType(C, arguments[E]), $.push(m[E]);
        var J = n.apply(null, $);
        function gr(ur) {
          if (c)
            Pr(C);
          else
            for (var Z = s ? 1 : 2; Z < e.length; Z++) {
              var Ht = Z === 1 ? j : m[Z - 2];
              e[Z].destructorFunction !== null && e[Z].destructorFunction(Ht);
            }
          if (l)
            return e[0].fromWireType(ur);
        }
        return gr(J);
      };
    }
    var Se = (r, e, t) => {
      if (r[e].overloadTable === void 0) {
        var n = r[e];
        r[e] = function() {
          return r[e].overloadTable.hasOwnProperty(arguments.length) || A(`Function '${t}' called with an invalid number of arguments (${arguments.length}) - expects one of (${r[e].overloadTable})!`), r[e].overloadTable[arguments.length].apply(this, arguments);
        }, r[e].overloadTable = [], r[e].overloadTable[n.argCount] = n;
      }
    }, xe = (r, e, t) => {
      f.hasOwnProperty(r) ? ((t === void 0 || f[r].overloadTable !== void 0 && f[r].overloadTable[t] !== void 0) && A(`Cannot register public name '${r}' twice`), Se(f, r, r), f.hasOwnProperty(t) && A(`Cannot register multiple overloads of a function with the same number of arguments (${t})!`), f[r].overloadTable[t] = e) : (f[r] = e, t !== void 0 && (f[r].numArguments = t));
    }, Oe = (r, e) => {
      for (var t = [], n = 0; n < r; n++)
        t.push(d[e + n * 4 >> 2]);
      return t;
    }, je = (r, e, t) => {
      f.hasOwnProperty(r) || kr("Replacing nonexistant public symbol"), f[r].overloadTable !== void 0 && t !== void 0 ? f[r].overloadTable[t] = e : (f[r] = e, f[r].argCount = t);
    }, De = (r, e, t) => {
      var n = f["dynCall_" + r];
      return t && t.length ? n.apply(null, [e].concat(t)) : n.call(null, e);
    }, fr = [], jr, _ = (r) => {
      var e = fr[r];
      return e || (r >= fr.length && (fr.length = r + 1), fr[r] = e = jr.get(r)), e;
    }, Ie = (r, e, t) => {
      if (r.includes("j"))
        return De(r, e, t);
      var n = _(e).apply(null, t);
      return n;
    }, Me = (r, e) => {
      var t = [];
      return function() {
        return t.length = 0, Object.assign(t, arguments), Ie(r, e, t);
      };
    }, G = (r, e) => {
      r = w(r);
      function t() {
        return r.includes("j") ? Me(r, e) : _(e);
      }
      var n = t();
      return typeof n != "function" && A(`unknown function pointer with signature ${r}: ${e}`), n;
    };
    function He(r, e) {
      return r = We(r), { [r]: function() {
        return e.apply(this, arguments);
      } }[r];
    }
    var Ve = (r, e) => {
      var t = He(e, function(n) {
        this.name = e, this.message = n;
        var i = new Error(n).stack;
        i !== void 0 && (this.stack = this.toString() + `
` + i.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.prototype.toString = function() {
        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
      }, t;
    }, Dr, Ir = (r) => {
      var e = Zr(r), t = w(e);
      return k(e), t;
    }, Be = (r, e) => {
      var t = [], n = {};
      function i(a) {
        if (!n[a] && !O[a]) {
          if (sr[a]) {
            sr[a].forEach(i);
            return;
          }
          t.push(a), n[a] = !0;
        }
      }
      throw e.forEach(i), new Dr(`${r}: ` + t.map(Ir).join([", "]));
    }, Ze = (r) => {
      r = r.trim();
      const e = r.indexOf("(");
      return e !== -1 ? (Jr(r[r.length - 1] == ")", "Parentheses for argument names should match."), r.substr(0, e)) : r;
    }, Ne = (r, e, t, n, i, a, o) => {
      var s = Oe(e, t);
      r = w(r), r = Ze(r), i = G(n, i), xe(r, function() {
        Be(`Cannot call ${r} due to unbound types`, s);
      }, e - 1), Wr([], s, function(c) {
        var u = [c[0], null].concat(c.slice(1));
        return je(r, Ue(r, u, null, i, a), e - 1), [];
      });
    }, Xe = (r, e, t) => {
      switch (e) {
        case 1:
          return t ? (n) => U[n >> 0] : (n) => b[n >> 0];
        case 2:
          return t ? (n) => L[n >> 1] : (n) => ir[n >> 1];
        case 4:
          return t ? (n) => H[n >> 2] : (n) => d[n >> 2];
        default:
          throw new TypeError(`invalid integer width (${e}): ${r}`);
      }
    }, Le = (r, e, t, n, i) => {
      e = w(e);
      var a = (l) => l;
      if (n === 0) {
        var o = 32 - 8 * t;
        a = (l) => l << o >>> o;
      }
      var s = e.includes("unsigned"), c = (l, v) => {
      }, u;
      s ? u = function(l, v) {
        return c(v, this.name), v >>> 0;
      } : u = function(l, v) {
        return c(v, this.name), v;
      }, F(r, { name: e, fromWireType: a, toWireType: u, argPackAdvance: W, readValueFromPointer: Xe(e, t, n !== 0), destructorFunction: null });
    }, qe = (r, e, t) => {
      var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], i = n[e];
      function a(o) {
        var s = d[o >> 2], c = d[o + 4 >> 2];
        return new i(U.buffer, c, s);
      }
      t = w(t), F(r, { name: t, fromWireType: a, argPackAdvance: W, readValueFromPointer: a }, { ignoreDuplicateRegistrations: !0 });
    };
    function ze(r) {
      return this.fromWireType(d[r >> 2]);
    }
    var Ge = (r, e, t, n) => {
      if (!(n > 0))
        return 0;
      for (var i = t, a = t + n - 1, o = 0; o < r.length; ++o) {
        var s = r.charCodeAt(o);
        if (s >= 55296 && s <= 57343) {
          var c = r.charCodeAt(++o);
          s = 65536 + ((s & 1023) << 10) | c & 1023;
        }
        if (s <= 127) {
          if (t >= a)
            break;
          e[t++] = s;
        } else if (s <= 2047) {
          if (t + 1 >= a)
            break;
          e[t++] = 192 | s >> 6, e[t++] = 128 | s & 63;
        } else if (s <= 65535) {
          if (t + 2 >= a)
            break;
          e[t++] = 224 | s >> 12, e[t++] = 128 | s >> 6 & 63, e[t++] = 128 | s & 63;
        } else {
          if (t + 3 >= a)
            break;
          e[t++] = 240 | s >> 18, e[t++] = 128 | s >> 12 & 63, e[t++] = 128 | s >> 6 & 63, e[t++] = 128 | s & 63;
        }
      }
      return e[t] = 0, t - i;
    }, Ke = (r, e, t) => Ge(r, b, e, t), Je = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n <= 127 ? e++ : n <= 2047 ? e += 2 : n >= 55296 && n <= 57343 ? (e += 4, ++t) : e += 3;
      }
      return e;
    }, Mr = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, Qe = (r, e, t) => {
      for (var n = e + t, i = e; r[i] && !(i >= n); )
        ++i;
      if (i - e > 16 && r.buffer && Mr)
        return Mr.decode(r.subarray(e, i));
      for (var a = ""; e < i; ) {
        var o = r[e++];
        if (!(o & 128)) {
          a += String.fromCharCode(o);
          continue;
        }
        var s = r[e++] & 63;
        if ((o & 224) == 192) {
          a += String.fromCharCode((o & 31) << 6 | s);
          continue;
        }
        var c = r[e++] & 63;
        if ((o & 240) == 224 ? o = (o & 15) << 12 | s << 6 | c : o = (o & 7) << 18 | s << 12 | c << 6 | r[e++] & 63, o < 65536)
          a += String.fromCharCode(o);
        else {
          var u = o - 65536;
          a += String.fromCharCode(55296 | u >> 10, 56320 | u & 1023);
        }
      }
      return a;
    }, Ye = (r, e) => r ? Qe(b, r, e) : "", rt = (r, e) => {
      e = w(e);
      var t = e === "std::string";
      F(r, { name: e, fromWireType(n) {
        var i = d[n >> 2], a = n + 4, o;
        if (t)
          for (var s = a, c = 0; c <= i; ++c) {
            var u = a + c;
            if (c == i || b[u] == 0) {
              var l = u - s, v = Ye(s, l);
              o === void 0 ? o = v : (o += String.fromCharCode(0), o += v), s = u + 1;
            }
          }
        else {
          for (var m = new Array(i), c = 0; c < i; ++c)
            m[c] = String.fromCharCode(b[a + c]);
          o = m.join("");
        }
        return k(n), o;
      }, toWireType(n, i) {
        i instanceof ArrayBuffer && (i = new Uint8Array(i));
        var a, o = typeof i == "string";
        o || i instanceof Uint8Array || i instanceof Uint8ClampedArray || i instanceof Int8Array || A("Cannot pass non-string to std::string"), t && o ? a = Je(i) : a = i.length;
        var s = pr(4 + a + 1), c = s + 4;
        if (d[s >> 2] = a, t && o)
          Ke(i, c, a + 1);
        else if (o)
          for (var u = 0; u < a; ++u) {
            var l = i.charCodeAt(u);
            l > 255 && (k(c), A("String has UTF-16 code units that do not fit in 8 bits")), b[c + u] = l;
          }
        else
          for (var u = 0; u < a; ++u)
            b[c + u] = i[u];
        return n !== null && n.push(k, s), s;
      }, argPackAdvance: W, readValueFromPointer: ze, destructorFunction(n) {
        k(n);
      } });
    }, Hr = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, et = (r, e) => {
      for (var t = r, n = t >> 1, i = n + e / 2; !(n >= i) && ir[n]; )
        ++n;
      if (t = n << 1, t - r > 32 && Hr)
        return Hr.decode(b.subarray(r, t));
      for (var a = "", o = 0; !(o >= e / 2); ++o) {
        var s = L[r + o * 2 >> 1];
        if (s == 0)
          break;
        a += String.fromCharCode(s);
      }
      return a;
    }, tt = (r, e, t) => {
      if (t === void 0 && (t = 2147483647), t < 2)
        return 0;
      t -= 2;
      for (var n = e, i = t < r.length * 2 ? t / 2 : r.length, a = 0; a < i; ++a) {
        var o = r.charCodeAt(a);
        L[e >> 1] = o, e += 2;
      }
      return L[e >> 1] = 0, e - n;
    }, nt = (r) => r.length * 2, it = (r, e) => {
      for (var t = 0, n = ""; !(t >= e / 4); ) {
        var i = H[r + t * 4 >> 2];
        if (i == 0)
          break;
        if (++t, i >= 65536) {
          var a = i - 65536;
          n += String.fromCharCode(55296 | a >> 10, 56320 | a & 1023);
        } else
          n += String.fromCharCode(i);
      }
      return n;
    }, at = (r, e, t) => {
      if (t === void 0 && (t = 2147483647), t < 4)
        return 0;
      for (var n = e, i = n + t - 4, a = 0; a < r.length; ++a) {
        var o = r.charCodeAt(a);
        if (o >= 55296 && o <= 57343) {
          var s = r.charCodeAt(++a);
          o = 65536 + ((o & 1023) << 10) | s & 1023;
        }
        if (H[e >> 2] = o, e += 4, e + 4 > i)
          break;
      }
      return H[e >> 2] = 0, e - n;
    }, ot = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n >= 55296 && n <= 57343 && ++t, e += 4;
      }
      return e;
    }, st = (r, e, t) => {
      t = w(t);
      var n, i, a, o, s;
      e === 2 ? (n = et, i = tt, o = nt, a = () => ir, s = 1) : e === 4 && (n = it, i = at, o = ot, a = () => d, s = 2), F(r, { name: t, fromWireType: (c) => {
        for (var u = d[c >> 2], l = a(), v, m = c + 4, $ = 0; $ <= u; ++$) {
          var C = c + 4 + $ * e;
          if ($ == u || l[C >> s] == 0) {
            var j = C - m, E = n(m, j);
            v === void 0 ? v = E : (v += String.fromCharCode(0), v += E), m = C + e;
          }
        }
        return k(c), v;
      }, toWireType: (c, u) => {
        typeof u != "string" && A(`Cannot pass non-string to C++ string type ${t}`);
        var l = o(u), v = pr(4 + l + e);
        return d[v >> 2] = l >> s, i(u, v + 4, l + e), c !== null && c.push(k, v), v;
      }, argPackAdvance: W, readValueFromPointer: hr, destructorFunction(c) {
        k(c);
      } });
    }, ft = (r, e, t, n, i, a) => {
      or[r] = { name: w(e), rawConstructor: G(t, n), rawDestructor: G(i, a), fields: [] };
    }, ct = (r, e, t, n, i, a, o, s, c, u) => {
      or[r].fields.push({ fieldName: w(e), getterReturnType: t, getter: G(n, i), getterContext: a, setterArgumentType: o, setter: G(s, c), setterContext: u });
    }, ut = (r, e) => {
      e = w(e), F(r, { isVoid: !0, name: e, argPackAdvance: 0, fromWireType: () => {
      }, toWireType: (t, n) => {
      } });
    }, lt = {}, vt = (r) => {
      var e = lt[r];
      return e === void 0 ? w(r) : e;
    }, Vr = () => {
      if (typeof globalThis == "object")
        return globalThis;
      function r(e) {
        e.$$$embind_global$$$ = e;
        var t = typeof $$$embind_global$$$ == "object" && e.$$$embind_global$$$ == e;
        return t || delete e.$$$embind_global$$$, t;
      }
      if (typeof $$$embind_global$$$ == "object" || (typeof global == "object" && r(global) ? $$$embind_global$$$ = global : typeof self == "object" && r(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == "object"))
        return $$$embind_global$$$;
      throw Error("unable to get global object.");
    }, dt = (r) => r === 0 ? B.toHandle(Vr()) : (r = vt(r), B.toHandle(Vr()[r])), _t = (r) => {
      r > 4 && (T.get(r).refcount += 1);
    }, ht = (r, e) => {
      var t = O[r];
      return t === void 0 && A(e + " has unknown type " + Ir(r)), t;
    }, pt = (r) => {
      var e = new Array(r + 1);
      return function(t, n, i) {
        e[0] = t;
        for (var a = 0; a < r; ++a) {
          var o = ht(d[n + a * 4 >> 2], "parameter " + a);
          e[a + 1] = o.readValueFromPointer(i), i += o.argPackAdvance;
        }
        var s = new (t.bind.apply(t, e))();
        return B.toHandle(s);
      };
    }, Br = {}, gt = (r, e, t, n) => {
      r = B.toValue(r);
      var i = Br[e];
      return i || (i = pt(e), Br[e] = i), i(r, t, n);
    }, yt = () => {
      z("");
    }, mt = (r, e, t) => b.copyWithin(r, e, e + t), bt = () => 2147483648, wt = (r) => {
      var e = nr.buffer, t = (r - e.byteLength + 65535) / 65536;
      try {
        return nr.grow(t), wr(), 1;
      } catch {
      }
    }, At = (r) => {
      var e = b.length;
      r >>>= 0;
      var t = bt();
      if (r > t)
        return !1;
      for (var n = (c, u) => c + (u - c % u) % u, i = 1; i <= 4; i *= 2) {
        var a = e * (1 + 0.2 / i);
        a = Math.min(a, r + 100663296);
        var o = Math.min(t, n(Math.max(r, a), 65536)), s = wt(o);
        if (s)
          return !0;
      }
      return !1;
    }, Tt = (r) => r;
    Fr = f.InternalError = class extends Error {
      constructor(e) {
        super(e), this.name = "InternalError";
      }
    }, be(), Sr = f.BindingError = class extends Error {
      constructor(e) {
        super(e), this.name = "BindingError";
      }
    }, Te(), Ee(), Dr = f.UnboundTypeError = Ve(Error, "UnboundTypeError");
    var $t = { u: ue, v: le, a: de, l: _e, s: he, M: pe, m: ge, f: ve, O: ye, F: me, J: Ae, I: Re, A: Pe, N: Ne, r: Le, p: qe, z: rt, w: st, Q: ft, P: ct, K: ut, C: Or, E: dt, x: _t, D: gt, y: yt, H: mt, G: At, t: It, b: Et, e: kt, k: jt, h: Ft, j: Mt, L: Dt, i: Wt, d: Rt, g: Ot, c: xt, o: Pt, n: Ct, q: St, B: Ut, R: Tt }, h = ce(), pr = f._malloc = (r) => (pr = f._malloc = h.U)(r), k = f._free = (r) => (k = f._free = h.V)(r), Zr = (r) => (Zr = h.X)(r);
    f.__embind_initialize_bindings = () => (f.__embind_initialize_bindings = h.Y)();
    var p = (r, e) => (p = h.Z)(r, e), K = (r) => (K = h._)(r), g = () => (g = h.$)(), y = (r) => (y = h.aa)(r), Nr = (r) => (Nr = h.ba)(r), Xr = (r) => (Xr = h.ca)(r), Lr = (r, e, t) => (Lr = h.da)(r, e, t), qr = (r) => (qr = h.ea)(r);
    function Et(r, e) {
      var t = g();
      try {
        return _(r)(e);
      } catch (n) {
        if (y(t), n !== n + 0)
          throw n;
        p(1, 0);
      }
    }
    function Rt(r, e) {
      var t = g();
      try {
        _(r)(e);
      } catch (n) {
        if (y(t), n !== n + 0)
          throw n;
        p(1, 0);
      }
    }
    function Ct(r, e, t, n, i, a) {
      var o = g();
      try {
        _(r)(e, t, n, i, a);
      } catch (s) {
        if (y(o), s !== s + 0)
          throw s;
        p(1, 0);
      }
    }
    function Pt(r, e, t, n, i) {
      var a = g();
      try {
        _(r)(e, t, n, i);
      } catch (o) {
        if (y(a), o !== o + 0)
          throw o;
        p(1, 0);
      }
    }
    function Ft(r, e, t, n, i) {
      var a = g();
      try {
        return _(r)(e, t, n, i);
      } catch (o) {
        if (y(a), o !== o + 0)
          throw o;
        p(1, 0);
      }
    }
    function kt(r, e, t) {
      var n = g();
      try {
        return _(r)(e, t);
      } catch (i) {
        if (y(n), i !== i + 0)
          throw i;
        p(1, 0);
      }
    }
    function Wt(r) {
      var e = g();
      try {
        _(r)();
      } catch (t) {
        if (y(e), t !== t + 0)
          throw t;
        p(1, 0);
      }
    }
    function Ut(r, e, t, n, i, a, o, s, c, u, l) {
      var v = g();
      try {
        _(r)(e, t, n, i, a, o, s, c, u, l);
      } catch (m) {
        if (y(v), m !== m + 0)
          throw m;
        p(1, 0);
      }
    }
    function St(r, e, t, n, i, a, o, s, c) {
      var u = g();
      try {
        _(r)(e, t, n, i, a, o, s, c);
      } catch (l) {
        if (y(u), l !== l + 0)
          throw l;
        p(1, 0);
      }
    }
    function xt(r, e, t, n) {
      var i = g();
      try {
        _(r)(e, t, n);
      } catch (a) {
        if (y(i), a !== a + 0)
          throw a;
        p(1, 0);
      }
    }
    function Ot(r, e, t) {
      var n = g();
      try {
        _(r)(e, t);
      } catch (i) {
        if (y(n), i !== i + 0)
          throw i;
        p(1, 0);
      }
    }
    function jt(r, e, t, n) {
      var i = g();
      try {
        return _(r)(e, t, n);
      } catch (a) {
        if (y(i), a !== a + 0)
          throw a;
        p(1, 0);
      }
    }
    function Dt(r, e, t, n, i, a, o) {
      var s = g();
      try {
        return _(r)(e, t, n, i, a, o);
      } catch (c) {
        if (y(s), c !== c + 0)
          throw c;
        p(1, 0);
      }
    }
    function It(r) {
      var e = g();
      try {
        return _(r)();
      } catch (t) {
        if (y(e), t !== t + 0)
          throw t;
        p(1, 0);
      }
    }
    function Mt(r, e, t, n, i, a) {
      var o = g();
      try {
        return _(r)(e, t, n, i, a);
      } catch (s) {
        if (y(o), s !== s + 0)
          throw s;
        p(1, 0);
      }
    }
    var cr;
    q = function r() {
      cr || zr(), cr || (q = r);
    };
    function zr() {
      if (S > 0 || (Qr(), S > 0))
        return;
      function r() {
        cr || (cr = !0, f.calledRun = !0, !yr && (Yr(), Y(f), f.onRuntimeInitialized && f.onRuntimeInitialized(), re()));
      }
      f.setStatus ? (f.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          f.setStatus("");
        }, 1), r();
      }, 1)) : r();
    }
    if (f.preInit)
      for (typeof f.preInit == "function" && (f.preInit = [f.preInit]); f.preInit.length > 0; )
        f.preInit.pop()();
    return zr(), Q.ready;
  };
})();
function Lt(I) {
  return Vt(Gr, I);
}
async function qt(I, {
  format: Q = D.format,
  charset: f = D.charset,
  quietZone: Y = D.quietZone,
  width: M = D.width,
  height: rr = D.height,
  eccLevel: er = D.eccLevel
} = D) {
  return Bt(
    I,
    {
      format: Q,
      charset: f,
      quietZone: Y,
      width: M,
      height: rr,
      eccLevel: er
    },
    Gr
  );
}
export {
  Kt as ZXING_BARCODE_FORMAT_NAMES,
  Jt as ZXING_CHARACTOR_SET_NAMES,
  Qt as defaultZXingReadOptions,
  D as defaultZXingWriteOptions,
  Lt as getZXingModule,
  Yt as purgeZXingModule,
  rn as setZXingModuleOverrides,
  qt as writeBarcodeToImageFile
};
